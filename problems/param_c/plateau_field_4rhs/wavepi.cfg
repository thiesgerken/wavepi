# WavePI settings file
# generated by wavepi 9f108093 (built 2018-03-01T14:48:53Z)

subsection LogTransform
  # transformation function for log transform is φ(x) = log(x-x₀), where
  # x₀ is the lower bound you want to enforce.
  set lower bound = 0.0
end
subsection WaveEquation
  # maximum iteration threshold for the solution of linear systems
  set max iter = 10000

  # parameter θ in the time discretization (θ=1 -> backward euler, θ=0 ->
  # forward euler, θ=0.5 -> Crank-Nicolson
  set theta    = 0.5

  # rel. tolerance for the solution of linear systems
  set tol      = 1e-8
end
subsection constraints
  # lower bound for reconstructed parameter
  set lower bound = 0.1   # default: -1e300

  # upper bound for reconstructed parameter
  set upper bound = 1e300
end
subsection general
  # problem dimension
  set dimension             = 2

  # polynomial degree of finite elements. Note that bound checking is
  # currently only implemented for linear elements.
  set finite element degree = 1

  # order of quadrature (QGauss, exact in polynomials of degree ≤ 2n-1, use
  # at least finite element degree + 1)
  set quadrature order      = 3
end
subsection inversion
  # solver for the inverse problem
  set method = REGINN

  # parameter τ for discrepancy principle
  set tau    = 2

  subsection NonlinearLandweber
    # relaxation factor ω
    set omega = 1
  end
  subsection REGINN
    # regularization method for the linear subproblems
    set linear solver            = ConjugateGradients

    # algorithm that chooses the maximum iteration counts for the linear
    # subproblems
    set maximum iteration choice = Fibonacci          # default: Constant

    # algorithm that chooses the target discrepancies for the linear
    # subproblems
    set tolerance choice         = Rieder

    # output of tolerances and linear steps (csv and gnuplot)
    set tolerance output         = history_reginn

    subsection ConjugateGradients
      # interpolate between the last two iterates such that the target
      # discrepancy is exactly reached
      set safeguarding = true
    end
    subsection ConstantMaxIterChoice
      # constant maximum iteration threshold. Set to ≤ 0 to diable.
      set maximum iteration count = 0
    end
    subsection ConstantToleranceChoice
      # rel. tolerance
      set tol = 0.7
    end
    subsection FibonacciMaxIterChoice
      # maximum iteration count for the first inner iteration
      set initial max iter = 1
    end
    subsection Landweber
      # relaxation factor ω
      set omega = 1
    end
    subsection RiederToleranceChoice
      # allowed speed of iteration numbers
      set beta      = 1.0

      # rel. maximum tolerance
      set tol max   = 0.999

      # rel. starting tolerance
      set tol start = 0.9

      # factor to decrease tolerance by
      set zeta      = 0.95
    end
    subsection inner output
      # output path for step {{i}}; has to end with a slash
      set destination = ./step-{{i}}/

      # output stats of inner iteration every n outer iterations, or never if
      # n == 0.
      set interval    = 10

      # output file for statistics (no extension). You can also use {{i}}
      # here.
      set statistics  = stats
    end
    subsection linear watchdog
      # abort if discrepancy increases
      set discrepancy increasing       = true

      # enable slope checking only if computed from at least this many
      # entries
      set discrepancy slope min values = 40

      # fraction of discrepancies that should be used to get slope. Set to ≤
      # 0 to disable slope checking.
      set discrepancy slope percentage = 0.25

      # threshold for slope of discrepancy.
      set discrepancy slope threshold  = 0.0

      # threshold for discrepancy: abort if it exceeds this factor times the
      # initial discrepancy. Set to ≤ 1 to disable.
      set discrepancy threshold        = 10.0
    end
  end
end
subsection log
  # depth for stdout
  set console depth = 2

  # external log file
  set file          = wavepi.log

  # depth for the log file
  set file depth    = 4
end
subsection mesh
  # time horizon T
  set end time           = 6

  # refines of the (initial) spatial grid
  set initial refines    = 7   # default: 5

  # (initial) number of time steps
  set initial time steps = 256

  subsection shape
    # generator for the triangulation
    set generator name = hyper_cube

    # options for the generator, in the form `var1=value1, var2=value2, ...`.
    # Available options: left, right for hyper_cube and hyper_L,
    # center_{x,y,z} and radius for hyper_cube, scale for cheese.
    set options        = left=-4.0, right=4.0 # default: left=-1.0, right=1.0
  end
end
subsection output
  # output the problem's right hand side on the first iteration
  set data                 = true

  # output path for step {{i}}; has to end with a slash
  set destination          = ./step-{{i}}/

  # output if the discrepancy decreased by at least this factor since the last
  # output. Set to ≤ 0 to disable this rule.
  set discrepancy decrease = 0.25

  # output the current estimate
  set estimate             = true

  # output the transformed current estimate
  set estimate transformed = false

  # output the problem's exact solution on the first iteration
  # (if available and discretized on first grid)
  set exact                = true

  # output the problem's exact solution on the first iteration
  # (if available and discretized on first grid)
  set exact transformed    = false

  # output every n iterations, or never by this rule if n == 0.
  set interval             = 50            # default: 10

  # output the last iteration before exit
  set last                 = true

  # output the current residual
  set residual             = true

  # Output file for rdisc, (r)norm and (r)error (if available) of estimate. If
  # not empty, this will result in [file].csv and [file].svg.
  set statistics           = history
end
subsection problem
  # Factor α in front of derivative term of H^1([0,T], L^2) dot product
  set H1L2 alpha       = 0.5

  # Factor α in front of first derivative term of H^2([0,T], L^2) dot
  # product
  set H2L2 alpha       = 0.5

  # Factor β in front of second derivative term of H^2([0,T], L^2) dot
  # product
  set H2L2 beta        = 0.25

  # constants for the function declarations,
  # in the form `var1=value1, var2=value2, ...`.
  set constants        = 

  # relative noise level ε
  set epsilon          = 1e-3                                        # default: 1e-2

  # initial guess
  set initial guess    = 2.0                                         # default: 0.5

  # Set the norm to use for fields. Be aware that this has to match the norm
  # that the measurements expect its inputs to have.
  set norm of codomain = L2L2

  # norm to use for parameters (incl. the reconstruction)
  set norm of domain   = H1L2                                        # default: L2L2

  # parameter a
  set parameter a      = 1.0

  # parameter c
  set parameter c      = if(norm{x|y|z} < 1.5, 2.0+abs(sin(t)), 2.0) # default: 2.0

  # parameter ν
  set parameter nu     = 0.0

  # parameter q
  set parameter q      = 0.0

  # transformation to apply to the parameter (e.g. to get rid of constraints)
  set transform        = Identity

  # parameter that is reconstructed
  set type             = c                                           # default: a

  subsection data
    # configuration to use for which right hand side, separated by semicolons
    set configurations             = 0;0;0;0                                                                                                                                                                                                                                 # default: 0

    # Number of right hand sides
    set number of right hand sides = 4                                                                                                                                                                                                                                       # default: 1

    # right hand sides, separated by semicolons
    set right hand sides           = if(t<3, if(norm{x-1.3|y-1.3|z} < 0.25, sin(3*t), 0.0), 0);if(t<3, if(norm{x-1.3|y+1.3|z} < 0.25, sin(3*t), 0.0), 0);if(t<3, if(norm{x+1.3|y-1.3|z} < 0.25, sin(3*t), 0.0), 0);if(t<3, if(norm{x+1.3|y+1.3|z} < 0.25, sin(3*t), 0.0), 0) # default: if(norm{x|y|z} < 0.2, sin(t), 0.0)

    subsection config 0
      # type of measurements
      set measure             = Field

      # in case of simulated sensors, their location on the mesh
      set sensor distribution = Grid

      subsection ConvolutionMeasure
        # scaling of shape function in spatial variables
        set radius space = 0.2

        # scaling of shape function in time variable
        set radius time  = 0.2

        # shape of the delta approximating function.
        set shape        = hat
      end
      subsection CubeBoundaryDistribution
        # points for the grid in time. Format: '[lower
        # bound]:[n_points]:[ub]'. Upper bound is inclusive, lower bound is
        # exclusive iff it equals 0.0.
        set points t = 0:10:6

        # points for the grid in x-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are inclusive, so they define the margin
        # to the boundary of the cube.
        set points x = -0.9:10:0.9

        # points for the grid in y-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are inclusive, so they define the margin
        # to the boundary of the cube.
        set points y = -0.9:10:0.9

        # points for the grid in z-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are inclusive, so they define the margin
        # to the boundary of the cube.
        set points z = -0.9:10:0.9
      end
      subsection GridDistribution
        # points for the grid in time. Format: '[lower
        # bound]:[n_points]:[ub]'. Upper bound is inclusive, lower bound is
        # exclusive iff it equals 0.0.
        set points t = 0:10:6

        # points for the grid in x-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are exclusive.
        set points x = -1:10:1

        # points for the grid in y-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are exclusive.
        set points y = -1:10:1

        # points for the grid in z-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are exclusive.
        set points z = -1:10:1
      end
    end
    subsection config 1
      # type of measurements
      set measure             = Field

      # in case of simulated sensors, their location on the mesh
      set sensor distribution = Grid

      subsection ConvolutionMeasure
        # scaling of shape function in spatial variables
        set radius space = 0.2

        # scaling of shape function in time variable
        set radius time  = 0.2

        # shape of the delta approximating function.
        set shape        = hat
      end
      subsection CubeBoundaryDistribution
        # points for the grid in time. Format: '[lower
        # bound]:[n_points]:[ub]'. Upper bound is inclusive, lower bound is
        # exclusive iff it equals 0.0.
        set points t = 0:10:6

        # points for the grid in x-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are inclusive, so they define the margin
        # to the boundary of the cube.
        set points x = -0.9:10:0.9

        # points for the grid in y-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are inclusive, so they define the margin
        # to the boundary of the cube.
        set points y = -0.9:10:0.9

        # points for the grid in z-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are inclusive, so they define the margin
        # to the boundary of the cube.
        set points z = -0.9:10:0.9
      end
      subsection GridDistribution
        # points for the grid in time. Format: '[lower
        # bound]:[n_points]:[ub]'. Upper bound is inclusive, lower bound is
        # exclusive iff it equals 0.0.
        set points t = 0:10:6

        # points for the grid in x-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are exclusive.
        set points x = -1:10:1

        # points for the grid in y-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are exclusive.
        set points y = -1:10:1

        # points for the grid in z-direction. Format: '[lb]:[n_points]:[ub]'.
        # Lower bound and upper bound are exclusive.
        set points z = -1:10:1
      end
    end
  end
end
subsection watchdog
  # abort if discrepancy increases
  set discrepancy increasing       = false

  # enable slope checking only if computed from at least this many entries
  set discrepancy slope min values = 40

  # fraction of discrepancies that should be used to get slope. Set to ≤ 0
  # to disable slope checking.
  set discrepancy slope percentage = 0.25

  # threshold for slope of discrepancy.
  set discrepancy slope threshold  = 0.0

  # threshold for discrepancy: abort if it exceeds this factor times the
  # initial discrepancy. Set to ≤ 1 to disable.
  set discrepancy threshold        = 10.0

  # maximal number of iterations (for iterative methods). Set to ≤ 0 to
  # disable.
  set maximum iteration count      = 0
end
